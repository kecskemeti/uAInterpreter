;
;  ========================================================================
;  uA Interpreter
;  ========================================================================
;  
;  This file is sample source code for the ua Interpreter.
;  
;  ua Interpreter is free software: you can redistribute it and/or
;  modify it under the terms of the GNU General Public License as published
;  by the Free Software Foundation, either version 3 of the License, or (at
;  your option) any later version.
;  
;  ua Interpreter is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of 
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;  General Public License for more details.
;
;  You should have received a copy of the GNU General Public License along
;  with ua Interpreter.  If not, see <http://www.gnu.org/licenses/>.
;  
;  (C) Copyright 2018, Gabor Kecskemeti (g.kecskemeti@ljmu.ac.uk)
;

; This program prints the "Hello World!" message just like HelloWorld.ua
;
; The program represents the above string in a 7 bit ASCII form. 
;    Consequently the program demonstrates a simple, compressed string data
;    type which has smaller memory requirements. This allows a more
;    efficient use of the variable memory space of the uA machine. 
; The program also demonstrates a few techniques to deal with numbers:
;    - Determine the sign bit of an integer (i.e., whether it is positve
;           or negative)
;    - Identify the binary form of an integer (could be useful for binary
;           printouts)
;    - Convert a binary number to an integer (could be useful when one
;           receives a binary number from the keyboard and needs to convert
;           it to a regular integer that can fit in uA's memory)
;    - Notice that the below conversion technique uses 1's complements.

;Memory map of the global variables used:
; -- 10000: the address of the next to be encoded item
; -- 10001: the number of bits still remaining in the current decoded 
;             number
; -- 10002: the number of bits still remaining from the encoded item
; -- 10003: the current value of the decoded number (this will be updated
;             based on the process)
; -- 10004: the screen location of the printout
; -- 10005: the actual value still in encoded form
; -- 10006: shows if the value that we are processing is negative (1) or
;             positive (0)


; The following numbers are equivalent of the following binary:
;    1001000 1100101 1101100 1101100 1101111 0100000 1110111 1101111
;    H       e       l       l       o               w       o
;    1110010 1101100 1100100 0100001 0000000 00000
;    r       l       d       !       Null
; This below is 12 bytes instead of the "CONST hw Hello World!"'s 52... 
CONNR hw1 -1285101174
CONNR hw2 -1476928488
CONNR hw3 541901

; The above number constants were generated by EncodeForUABinDecoder.java
; Similar encoding technique can be used in the compilers of languages that
;  aim at supporting such compressed string representations

entry:
; What to decode:
MVC hw1,A
STC 10000,A
; bits remaining from the full number
MVC 0,A
STC 10002,A
; the location of the printout
MVC 994,A
STC 10004,A
JMC startNewChar

notEnd:
; C holds the to be printed out value
; Let's load the screen location
LDC 10004,B
STR B,C
; Move the screen location by a bit
ADC 1,B
STC 10004,B


startNewChar:
; bits remaining from a single decode
MVC 7,A
STC 10001,A
; the current decoded number
MVC 0,A
STC 10003,A


checkRemEncoded:
LDC 10002,A
JZC processData,A

; New data needed

; Loads the encoded item
LDC 10000,A
LDR A,B
STC 10005,B

; Determines the sign bit of the encoded item
determineSign:
; Is it negative?
ADC 1,B
JZC nonMinusOne,B
; Yes it is -1!
MVC 1,B
JMC finalizeLoad
nonMinusOne:
ADC -2,B
JZC nonPlusOne,B
; Yes it is 1
MVC 0,B
JMC finalizeLoad
nonPlusOne:
ADC 1,B
JZC nonZero,B
; Yes it is 0
MVC 0,B
JMC finalizeLoad
nonZero:
; We need a smaller number for which we can determine the sign
DVC 2,B
JMC determineSign

;Sign bit determined, we now need to finalize the new encoded items' loading
finalizeLoad:
; Store the sign calculated above
STC 10006,B
; Resets the encoded item's length
MVC 32,B
STC 10002,B
; Points to the next item to encode
ADC 1,A
STC 10000,A

; We are ready to process the next bits

processData:
LDC 10002,A
ADC -1,A
JZC notLastBit,A
; this is the last bit in the current encoded data
;   which should be the original sign bit that was never modified by our
;   divisions
LDC 10006,A
JMC storeUpdated
notLastBit:
; We need to figure out what is the lowest bit in the currently encoded data
LDC 10005,A
MVR A,C
DVC 2,C
; The last bit is removed from the encoded data, we store the remainder
;   for future work
STC 10005,C
; Now we need to see what was the bit that we removed
MLC -2,C
; Here we can compare the original encoded data to the one which does not 
;   have the bit.
ADR C,A
; The next bit is now in A!
; If we had a negative encoded number, we need to do a complement on this
;   bit so it is really the actual one we want to use in the decoded number
LDC 10006,C
JZC complementNeeded,C
; We have had a positive encoded number, we have nothing else to do but to
;   store the bit recovered
JMC storeUpdated
complementNeeded:
; We have had a negative encoded number, we have to invert our bit
JZC zeroInvResult,A
; One inv result
MVC 1,A
JMC storeUpdated
zeroInvResult:
MVC 0,A
storeUpdated:
; By now we have the last decoded bit in A

; Let's load the partially decoded number (from the past)
LDC 10003,C
; Prepare it for the acceptance of the next bit
MLC 2,C
; Adding the last bit to the decoded number
ADR A,C
; Saving the current progress on the decoded number
STC 10003,C
; Updating the remaining decoded bits
LDC 10001,A
ADC -1,A
STC 10001,A
; Updating the remaining encoded bits
LDC 10002,B
ADC -1,B
STC 10002,B

; Was it the last decoded bit?
JZC checkRemEncoded,A
; Yes it was

; Complete data decoded is still in C
; Let's see if this is a zero character marking the end of a string
JZC notEnd,C
; We have reached the last bits to decode
exit:
; END OF PROGRAM!